local M = {}

local history_file = vim.fn.stdpath("state") .. "/loginspect_history.json"

--- Load filter history from file.
local function load_history()
  local f = io.open(history_file, "r")
  if not f then
    return {}
  end
  local content = f:read("*a")
  f:close()
  local ok, decoded = pcall(vim.fn.json_decode, content)
  return ok and decoded or {}
end

--- Save filter history to file.
-- TODO: proper type annotations.
-- TODO: only load history once from disk
local function save_history(history)
  local f = io.open(history_file, "w")
  if not f then
    vim.notify("Could not save history", vim.log.levels.ERROR)
    return
  end
  f:write(vim.fn.json_encode(history))
  f:close()
end

--- Filter the given buffer.
--- @param buffer integer Buffer id, or 0 for current buffer.
--- @param filters string[] Filters to apply, any line that matches any filter will be present in the output.
function M._do_filter(buffer, filters)
  if buffer == 0 then
    buffer = vim.api.nvim_get_current_buf()
  end

  -- Add to history
  local new_history = { { timestamp = os.date("%Y-%m-%d %H:%M:%S"), filters = filters } }
  for _, pair in ipairs(load_history()) do
    if pair[2] ~= filters then
      table.insert(new_history, pair)
    end
  end
  save_history(new_history)

  -- Filter lines
  local orig_lines = vim.api.nvim_buf_get_lines(buffer, 0, -1, false)
  local result_lines = {}
  for _, line in ipairs(orig_lines) do
    for _, f in ipairs(filters) do
      if string.find(line, f, 1, true) then
        table.insert(result_lines, line)
        break
      end
    end
  end

  -- Open new buffer with filtered lines.
  -- TODO: Add title to window
  local new_buf = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, result_lines)
  local _ = vim.api.nvim_open_win(new_buf, true, {
    relative = "editor",
    width = vim.o.columns - 2,
    height = vim.o.lines - 2,
    row = 0,
    col = 1,
    style = "minimal",
    border = "rounded",
  })

  -- Save filter session state to the new buffer
  vim.b.linefilter_is_filtered = true
  vim.b.linefilter_filters = filters
  vim.b.linefilter_source_buf = buffer

  -- 'q' to quit without action
  vim.api.nvim_buf_set_keymap(new_buf, "n", "q", "<cmd>bd!<CR>", { noremap = true, silent = true })
  -- '<leader>e' to edit current filters
  vim.api.nvim_buf_set_keymap(
    new_buf,
    "n",
    "<leader>e",
    ":lua require('loginspect').edit_active_filters() <cr>",
    { noremap = true, silent = true }
  )
end

--- Filter lines
-- TODO: make sure every string can contain complex chars
function M.filter_lines()
  vim.ui.input({ prompt = "Enter comma-separated strings: " }, function(input)
    if not input or input == "" then
      return
    end

    local filters = {}
    for str in string.gmatch(input, "([^,]+)") do
      table.insert(filters, vim.trim(str))
    end

    M._do_filter(0, filters)
  end)
end

--- Edit currently applied filters
function M.edit_active_filters()
  if not vim.b.linefilter_is_filtered then
    vim.notify("This buffer was not generated by LineFilter.", vim.log.levels.WARN)
    return
  end
  local current_buffer = vim.api.nvim_get_current_buf()

  local filters = vim.b.linefilter_filters or {}
  local source_buffer = vim.b.linefilter_source_buf

  local filter_buf = vim.api.nvim_create_buf(false, true) -- false: not listed, true: scratch
  vim.api.nvim_buf_set_lines(filter_buf, 0, -1, false, filters)

  -- Open the file in a floating window
  -- TODO: Add title to floating window, display keybinds as virtual text
  local width = math.floor(vim.o.columns * 0.6)
  local height = #filters + 5
  local row = math.floor((vim.o.lines - height) / 2)
  local col = math.floor((vim.o.columns - width) / 2)

  local _ = vim.api.nvim_open_win(filter_buf, true, {
    relative = "editor",
    width = width,
    height = height,
    row = row,
    col = col,
    style = "minimal",
    border = "rounded",
  })

  -- 'q' to quit without action
  vim.api.nvim_buf_set_keymap(filter_buf, "n", "q", "<cmd>bd!<CR>", { noremap = true, silent = true })

  -- <Enter> to apply new filters and close
  vim.keymap.set("n", "<CR>", function()
    -- Get all lines from the buffer
    local lines = vim.api.nvim_buf_get_lines(filter_buf, 0, -1, false)
    -- Filter out empty lines
    local new_filters = {}
    for _, line in ipairs(lines) do
      if line:match("%S") then -- matches any non-whitespace character
        table.insert(new_filters, line)
      end
    end
    -- Close the filter buffer (and its window)
    vim.api.nvim_buf_delete(filter_buf, { force = true })
    -- Close the filtered buffer
    vim.api.nvim_buf_delete(current_buffer, { force = true })

    -- Apply new filters to source buffer.
    M._do_filter(source_buffer, new_filters)
  end, { buffer = filter_buf, noremap = true, silent = true })
end

--- View history.
function M.filter_from_history()
  local history = load_history()
  local lines = {}

  -- Reverse iterate for most recent first
  for _, entry in ipairs(history) do
    local line = table.concat(entry.filters, ", ")
    table.insert(lines, line)
  end

  vim.ui.select(lines, { prompt = "Select filters from history:" }, function(_, idx)
    if idx then
      M._do_filter(0, history[idx].filters)
    end
  end)
end

--- Clear history.
function M.clear_filter_history()
  local f = io.open(history_file, "w")
  if f then
    f:write("[]") -- Write an empty JSON array
    f:close()
    vim.notify("LineFilter history cleared!", vim.log.levels.INFO)
  else
    vim.notify("Failed to clear LineFilter history", vim.log.levels.ERROR)
  end
end

--- Setup commands
function M.setup(_)
  vim.api.nvim_create_user_command("LineFilter", M.filter_lines, {})
  vim.api.nvim_create_user_command("LineFilterHistory", M.filter_from_history, {})
  vim.api.nvim_create_user_command("LineFilterClearHistory", M.clear_filter_history, {})
end

return M
