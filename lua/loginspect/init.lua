local M = {}

local history_file = vim.fn.stdpath("data") .. "/loginspect_history.json"

-- Load history from file
local function load_history()
  local f = io.open(history_file, "r")
  if not f then
    return {}
  end
  local content = f:read("*a")
  f:close()
  local ok, decoded = pcall(vim.fn.json_decode, content)
  return ok and decoded or {}
end

-- Save history to file
local function save_history(history)
  local f = io.open(history_file, "w")
  if not f then
    vim.notify("Could not save history", vim.log.levels.ERROR)
    return
  end
  f:write(vim.fn.json_encode(history))
  f:close()
end

-- Filter lines
function M.filter_lines()
  vim.ui.input({ prompt = "Enter comma-separated strings: " }, function(input)
    if not input or input == "" then
      return
    end

    local filters = {}
    for str in string.gmatch(input, "([^,]+)") do
      table.insert(filters, vim.trim(str))
    end

    -- Save to history
    local history = load_history()
    table.insert(history, { timestamp = os.date("%Y-%m-%d %H:%M"), filters = filters })
    save_history(history)

    local orig_buf = vim.api.nvim_get_current_buf()
    local orig_lines = vim.api.nvim_buf_get_lines(orig_buf, 0, -1, false)
    local result_lines = {}

    for _, line in ipairs(orig_lines) do
      for _, f in ipairs(filters) do
        if string.find(line, f, 1, true) then
          table.insert(result_lines, line)
          break
        end
      end
    end

    local new_buf = vim.api.nvim_create_buf(true, true)
    vim.api.nvim_set_current_buf(new_buf)
    vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, result_lines)

    -- Save filter session state to the new buffer
    vim.b.linefilter_is_filtered = true
    vim.b.linefilter_filters = filters
    vim.b.linefilter_source_buf = orig_buf
  end)
end

-- Edit filters
function M.edit_active_filters()
  if not vim.b.linefilter_is_filtered then
    vim.notify("This buffer was not generated by LineFilter", vim.log.levels.WARN)
    return
  end

  local filters = vim.b.linefilter_filters or {}

  local width = 50
  local height = math.max(#filters, 5)
  local row = math.floor((vim.o.lines - height) / 2)
  local col = math.floor((vim.o.columns - width) / 2)

  local popup_buf = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_buf_set_lines(popup_buf, 0, -1, false, filters)

  local win_opts = {
    relative = "editor",
    style = "minimal",
    border = "rounded",
    row = row,
    col = col,
    width = width,
    height = height,
  }

  local win = vim.api.nvim_open_win(popup_buf, true, win_opts)

  -- Mark it as a filter editing buffer
  vim.b[popup_buf].linefilter_filter_editor = true
  vim.b[popup_buf].linefilter_target_buf = vim.fn.bufnr("#")
  vim.b[popup_buf].linefilter_source_buf = vim.b.linefilter_source_buf

  -- Re-run filters on write
  vim.api.nvim_create_autocmd("BufWritePost", {
    buffer = popup_buf,
    callback = function()
      require("loginspect")._reapply_filters_from_editor()

      if vim.api.nvim_win_is_valid(win) then
        vim.api.nvim_win_close(win, true)
      end
    end,
    desc = "Reapply LineFilter and close popup on write",
  })

  -- Map 'q' to close the popup
  vim.keymap.set("n", "q", function()
    if vim.api.nvim_win_is_valid(win) then
      vim.api.nvim_win_close(win, true)
    end
  end, { buffer = popup_buf, silent = true })

  vim.notify("Edit filters in the popup. Write to re-apply.", vim.log.levels.INFO)
end

-- Reapply filters
function M._reapply_filters_from_editor()
  if not vim.b.linefilter_filter_editor then
    return
  end

  local filter_lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
  local filters = {}
  for _, f in ipairs(filter_lines) do
    if f ~= "" then
      table.insert(filters, f)
    end
  end

  local source_buf = vim.b.linefilter_source_buf
  if not vim.api.nvim_buf_is_valid(source_buf) then
    vim.notify("Source buffer is no longer valid", vim.log.levels.ERROR)
    return
  end

  local orig_lines = vim.api.nvim_buf_get_lines(source_buf, 0, -1, false)
  local result_lines = {}

  for _, line in ipairs(orig_lines) do
    for _, f in ipairs(filters) do
      if string.find(line, f, 1, true) then
        table.insert(result_lines, line)
        break
      end
    end
  end

  -- Overwrite the previous filtered buffer
  local target_buf = vim.b.linefilter_target_buf
  if vim.api.nvim_buf_is_valid(target_buf) then
    vim.api.nvim_buf_set_lines(target_buf, 0, -1, false, result_lines)
    vim.api.nvim_set_current_buf(target_buf)
    vim.b[target_buf].linefilter_filters = filters
  else
    vim.notify("Target buffer not found. Cannot update.", vim.log.levels.ERROR)
  end
end

-- View history
function M.view_history()
  local history = load_history()
  local lines = {}

  -- Reverse iterate for most recent first
  for i = #history, 1, -1 do
    local entry = history[i]
    local line = entry.timestamp .. ": " .. table.concat(entry.filters, ", ")
    table.insert(lines, line)
  end

  local new_buf = vim.api.nvim_create_buf(true, true)
  vim.api.nvim_set_current_buf(new_buf)
  vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, lines)
end

-- Clear history
function M.clear_history()
  local f = io.open(history_file, "w")
  if f then
    f:write("[]") -- Write an empty JSON array
    f:close()
    vim.notify("LineFilter history cleared!", vim.log.levels.INFO)
  else
    vim.notify("Failed to clear LineFilter history", vim.log.levels.ERROR)
  end
end

-- Save edited history
function M.save_edited_history()
  if not vim.b.linefilter_history_edit then
    vim.notify("This buffer is not marked as a LineFilter history edit", vim.log.levels.WARN)
    return
  end

  local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
  local new_history = {}

  for _, line in ipairs(lines) do
    local ok, decoded = pcall(vim.fn.json_decode, line)
    if not ok then
      vim.notify("Invalid JSON in history line: " .. line, vim.log.levels.ERROR)
      return
    end
    table.insert(new_history, decoded)
  end

  save_history(new_history)
  vim.notify("LineFilter history saved!", vim.log.levels.INFO)
end

-- Edit History
function M.edit_history()
  local history = load_history()
  local lines = {}

  for _, entry in ipairs(history) do
    table.insert(lines, vim.fn.json_encode(entry))
  end

  local buf = vim.api.nvim_create_buf(true, true)
  vim.api.nvim_set_current_buf(buf)
  vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)

  -- Mark the buffer as a history-editing buffer
  vim.b.linefilter_history_edit = true
  vim.b.linefilter_history_path = history_file

  -- Set autocommand to save when buffer is written
  vim.api.nvim_create_autocmd("BufWritePost", {
    buffer = buf,
    callback = function()
      require("loginspect").save_edited_history()
    end,
    desc = "Auto-save LineFilter history on write",
  })

  vim.notify("Editing LineFilter history. Changes will auto-save on write.", vim.log.levels.INFO)
end

-- Setup commands
function M.setup()
  vim.notify("loginspect: setup")
  vim.api.nvim_create_user_command("LineFilter", M.filter_lines, {})
  vim.api.nvim_create_user_command("LineFilterHistory", M.view_history, {})
  vim.api.nvim_create_user_command("LineFilterClearHistory", M.clear_history, {})
  vim.api.nvim_create_user_command("LineFilterEditActiveFilters", M.edit_active_filters, {})
end

return M
